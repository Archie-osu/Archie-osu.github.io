<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Hooking Context Swaps with ETW | Archie’s reversing diary</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="Hooking Context Swaps with ETW" />
<meta name="author" content="Archie" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Event Tracing for Windows (ETW) is a kernel mechanism designed to log certain activity happening in the system. Despite its seemingly innocuous description, ETW can be a valuable source of information and a very interesting hook point for both anti-cheats and other drivers. Part 1: Finding the hook point All ETW logging functions eventually end up inside nt!EtwpLogKernelEvent which, in summary, reserves a buffer for the log using nt!EtwpReserveTraceBuffer and then writes the log to that buffer. Deep inside nt!EtwpReserveTraceBuffer is where the real fun begins. The function accesses a _WMI_LOGGER_CONTEXT structure - the kernel’s representation of a logger - and looks at the GetCpuClock member before deciding on how to get the current time. Anyone who’s ever looked at how InfinityHook works will immediately recognize this member variable, as it was the hook point used by its creators. In the past, the variable was a function pointer that could be directly swapped to easily gain execution at each captured event. In an effort to patch InfinityHook, Microsoft turned the variable into an index, with each index representing a different way of getting time. Looking at the relevant code inside EtwpReserveTraceBuffer, we can deduce what indices are valid, together with their meaning: const auto get_cpu_clock = LoggerContext-&gt;GetCpuClock; LARGE_INTEGER current_time = { .QuadPart = 0 }; // Crash the computer if the index is invalid. if (get_cpu_clock &gt; 3) KeBugCheck(KERNEL_SECURITY_CHECK_FAILURE); switch (get_cpu_clock) { case 3: current_time.QuadPart = __rdtsc(); break; case 2: HalPrivateDispatchTable.HalTimerQueryHostPerformanceCounter(&amp;current_time); break; case 1: current_time = KeQueryPerformanceCounter(nullptr); break; case 0: current_time = RtlGetSystemTimePrecise(); break; default: KeBugCheck(KERNEL_SECURITY_CHECK_FAILURE); } For the purposes of this article, we’ll focus on what happens when the value is set to 1. At the beginning of the nt!KeQueryPerformanceCounter function, we can see the following snippet: UINT32 value_1 = *reinterpret_cast&lt;UINT32*&gt;(HalpPerformanceCounter + 0xE4); UINT32 value_2 = *reinterpret_cast&lt;UINT32*&gt;(HalpPerformanceCounter + 0xDC); LARGE_INTEGER result = { .QuadPart = 0 }; // This seems to always be true if (value_1 == 5) { PVOID internal_data = HalpTimerGetInternalData(HalpPerformanceCounter); if (HalpTimerReferencePage) { result = HalpPerformanceCounter-&gt;HalpQueryCounter(internal_data); } else { // ... result = HalpPerformanceCounter-&gt;HalpQueryCounter(internal_data); // ... } } Simply swapping the pointer to HalpQueryCounter is enough to get us a hook. There is just one problem - nt!KeQueryPerformanceCounter is a function that is called very often. It’s also impossible to set a breakpoint inside, as any connected kernel debugger will hang upon the breakpoint being hit. To prevent false positives (and get our debugger to work again), we need to figure out if calls made to our hook come from ETW. In the tested version of Windows 11 24H2, there is a pointer to the logger context in the r15 register if the call comes from ETW. In other versions of Windows (mainly Windows 10), one may have to resort to scanning the stack for pointers to the logger context. Part 2: Configuring the logger Making ETW call our hook is not that simple - we will first need to access the GetCpuClock variable of the _WMI_LOGGER_CONTEXT structure to make the kernel call our hook. While it is possible to create a new logger and get a pointer to the structure that way, I chose to instead hijack the Circular Kernel Context Logger (CKCL), as it is usually not used for anything important. A pointer to its context can be retrieved quite easily, as there is a pointer chain that leads us right to it. This pointer chain is stable for all tested versions of Windows, and is unlikely to change in the future. It begins at the undocumented nt!EtwpDebuggerData global, whose RVA can be found via parsing the PDB of ntoskrnl.exe. PWMI_LOGGER_CONTEXT GetCKCLContext( IN UINT_PTR EtwpDebuggerData ) { PVOID* debugger_data_silo = *reinterpret_cast&lt;PVOID**&gt;(EtwpDebuggerData + 0x10); return static_cast&lt;PWMI_LOGGER_CONTEXT&gt;(debugger_data_silo[2]); } We will also need to configure the logger’s target events (internally called EnableFlags). This is done via the nt!ZwTraceControl function, which is thankfully exported for all drivers to use. The function takes a _WMI_LOGGER_INFORMATION structure as the input buffer. While undocumented by Microsoft, its definition can be found inside PHNT headers. Inside this structure, we will need to specify what logger to target. This is done by setting the GUID and LoggerName. Already having the _WMI_LOGGER_CONTEXT structure, extracting the information is simple: kd&gt; dt _WMI_LOGGER_CONTEXT poi(poi(EtwpDebuggerData+0x10)+0x10) nt!_WMI_LOGGER_CONTEXT ... +0x088 LoggerName : _UNICODE_STRING &quot;Circular Kernel Context Logger&quot; ... +0x114 InstanceGuid : _GUID {54dea73a-ed1f-42a4-af71-3e63d056f174} Upon configuring the logger and starting it, we’re ready to roll. Part 3: Hooking context switches We now have a function that gets called on each context switch - awesome! Finding the new thread is simple - we’re executing in its context, meaning KeGetCurrentThread will get us a pointer to it’s object. Looking at the functions called prior to our hook, we notice that the last function that has access to the OldThread and NewThread parameters is EtwpLogContextSwapEvent, where they are passed in rdx and r8. Breakpointing there shows that rbx and rdi contain copies of the two arguments. 1: kd&gt; r rbx, rdx, rdi, r8 rbx=ffffd8878177d080 rdx=ffffd8878177d080 rdi=ffffd8878627c080 r8=ffffd8878627c080 nt!EtwpLogContextSwapEvent: fffff8028bbd79d0 48895c2410 mov qword ptr [rsp+10h],rbx ss:0018:fffff500a54bbef8=fffff8028bbd7885 These registers are both pushed onto the stack in the function prologue, with the current thread (stored in rdi and r8) coming first: kd&gt; uu EtwpLogContextSwapEvent nt!EtwpLogContextSwapEvent: fffff805`81bd79d0 48895c2410 mov qword ptr [rsp+10h],rbx fffff805`81bd79d5 55 push rbp fffff805`81bd79d6 56 push rsi fffff805`81bd79d7 57 push rdi Looking at the code, we can figure out that rbx will be at a constant offset of 0x28 from rdi on the stack. Given we know the value of rdi (it’s a pointer to the current thread), we can scan the stack up from our hook, and look at each possible thread: // We loop until stack_limit - 0x28 to prevent OOB access when checking the previous thread. for (ULONG_PTR iterator = rsp; iterator &lt; (stack_limit - 0x28); iterator += sizeof(PKTHREAD)) { PKTHREAD thread_at_iterator = *reinterpret_cast&lt;PKTHREAD*&gt;(iterator); // If we found our own thread&#39;s pointer on the stack if (thread_at_iterator == current_thread) { // Look at the thread at the target offset PKTHREAD possible_prev_thread = *reinterpret_cast&lt;PKTHREAD*&gt;(iterator + 0x28); PDISPATCHER_HEADER possible_dispatcher_header = reinterpret_cast&lt;PDISPATCHER_HEADER&gt;(possible_prev_thread) - 1; const ULONG_PTR possible_prev_thread_raw = *reinterpret_cast&lt;ULONG_PTR*&gt;(iterator + 0x28); // Threads are not stack-allocated. if (possible_prev_thread_raw &gt;= stack_base &amp;&amp; possible_prev_thread_raw &lt;= stack_limit) continue; // Threads are not in userspace. if (possible_prev_thread &lt; MmSystemRangeStart) continue; // Threads have accessible memory. if (!MmIsAddressValid(possible_prev_thread) || !MmIsAddressValid(possible_dispatcher_header)) continue; // Reference the thread to check the object type. NTSTATUS status = ObReferenceObjectByPointer( possible_prev_thread, 0, *PsThreadType, KernelMode ); // If the function fails, we can be sure that the address is not one of a thread. if (!NT_SUCCESS(status)) continue; // Dereference the thread, and store it. ObfDereferenceObject(possible_prev_thread); previous_thread = possible_prev_thread; break; } } Part 4: Usage &amp; Detection Many anti-cheat solutions have started hooking context swaps in an effort to create hidden memory regions that are only visible to certain threads in the system. One notable example is Riot Vanguard which uses a different method that I’ll definitely write about in the near future. The hook can also be used to detect threads executing in unsigned memory, as there’s little preventing you from walking the stack of the old thread, and seeing whether code is running in any region it shouldn’t be. As for detection, there’s the obvious artifact of HalpPerformanceCounter + 0x70 pointing outside of ntoskrnl.exe, and GetCpuClock being set to 1 in the CKCL. Although the latter may happen under normal system operation (and could therefore trigger false positives), it’s never been set by default over the course of my testing. Part 5: Epilogue This is my very first written article, inspired by reading countless posts from people far smarter than I am. One person I should definitely mention is Denis Skvortcov who wrote about this method more than two years ago when reverse-engineering Avast Antivirus. I should also thank you, the reader, for sticking with me this far - I hope we meet again next time!" />
<meta property="og:description" content="Event Tracing for Windows (ETW) is a kernel mechanism designed to log certain activity happening in the system. Despite its seemingly innocuous description, ETW can be a valuable source of information and a very interesting hook point for both anti-cheats and other drivers. Part 1: Finding the hook point All ETW logging functions eventually end up inside nt!EtwpLogKernelEvent which, in summary, reserves a buffer for the log using nt!EtwpReserveTraceBuffer and then writes the log to that buffer. Deep inside nt!EtwpReserveTraceBuffer is where the real fun begins. The function accesses a _WMI_LOGGER_CONTEXT structure - the kernel’s representation of a logger - and looks at the GetCpuClock member before deciding on how to get the current time. Anyone who’s ever looked at how InfinityHook works will immediately recognize this member variable, as it was the hook point used by its creators. In the past, the variable was a function pointer that could be directly swapped to easily gain execution at each captured event. In an effort to patch InfinityHook, Microsoft turned the variable into an index, with each index representing a different way of getting time. Looking at the relevant code inside EtwpReserveTraceBuffer, we can deduce what indices are valid, together with their meaning: const auto get_cpu_clock = LoggerContext-&gt;GetCpuClock; LARGE_INTEGER current_time = { .QuadPart = 0 }; // Crash the computer if the index is invalid. if (get_cpu_clock &gt; 3) KeBugCheck(KERNEL_SECURITY_CHECK_FAILURE); switch (get_cpu_clock) { case 3: current_time.QuadPart = __rdtsc(); break; case 2: HalPrivateDispatchTable.HalTimerQueryHostPerformanceCounter(&amp;current_time); break; case 1: current_time = KeQueryPerformanceCounter(nullptr); break; case 0: current_time = RtlGetSystemTimePrecise(); break; default: KeBugCheck(KERNEL_SECURITY_CHECK_FAILURE); } For the purposes of this article, we’ll focus on what happens when the value is set to 1. At the beginning of the nt!KeQueryPerformanceCounter function, we can see the following snippet: UINT32 value_1 = *reinterpret_cast&lt;UINT32*&gt;(HalpPerformanceCounter + 0xE4); UINT32 value_2 = *reinterpret_cast&lt;UINT32*&gt;(HalpPerformanceCounter + 0xDC); LARGE_INTEGER result = { .QuadPart = 0 }; // This seems to always be true if (value_1 == 5) { PVOID internal_data = HalpTimerGetInternalData(HalpPerformanceCounter); if (HalpTimerReferencePage) { result = HalpPerformanceCounter-&gt;HalpQueryCounter(internal_data); } else { // ... result = HalpPerformanceCounter-&gt;HalpQueryCounter(internal_data); // ... } } Simply swapping the pointer to HalpQueryCounter is enough to get us a hook. There is just one problem - nt!KeQueryPerformanceCounter is a function that is called very often. It’s also impossible to set a breakpoint inside, as any connected kernel debugger will hang upon the breakpoint being hit. To prevent false positives (and get our debugger to work again), we need to figure out if calls made to our hook come from ETW. In the tested version of Windows 11 24H2, there is a pointer to the logger context in the r15 register if the call comes from ETW. In other versions of Windows (mainly Windows 10), one may have to resort to scanning the stack for pointers to the logger context. Part 2: Configuring the logger Making ETW call our hook is not that simple - we will first need to access the GetCpuClock variable of the _WMI_LOGGER_CONTEXT structure to make the kernel call our hook. While it is possible to create a new logger and get a pointer to the structure that way, I chose to instead hijack the Circular Kernel Context Logger (CKCL), as it is usually not used for anything important. A pointer to its context can be retrieved quite easily, as there is a pointer chain that leads us right to it. This pointer chain is stable for all tested versions of Windows, and is unlikely to change in the future. It begins at the undocumented nt!EtwpDebuggerData global, whose RVA can be found via parsing the PDB of ntoskrnl.exe. PWMI_LOGGER_CONTEXT GetCKCLContext( IN UINT_PTR EtwpDebuggerData ) { PVOID* debugger_data_silo = *reinterpret_cast&lt;PVOID**&gt;(EtwpDebuggerData + 0x10); return static_cast&lt;PWMI_LOGGER_CONTEXT&gt;(debugger_data_silo[2]); } We will also need to configure the logger’s target events (internally called EnableFlags). This is done via the nt!ZwTraceControl function, which is thankfully exported for all drivers to use. The function takes a _WMI_LOGGER_INFORMATION structure as the input buffer. While undocumented by Microsoft, its definition can be found inside PHNT headers. Inside this structure, we will need to specify what logger to target. This is done by setting the GUID and LoggerName. Already having the _WMI_LOGGER_CONTEXT structure, extracting the information is simple: kd&gt; dt _WMI_LOGGER_CONTEXT poi(poi(EtwpDebuggerData+0x10)+0x10) nt!_WMI_LOGGER_CONTEXT ... +0x088 LoggerName : _UNICODE_STRING &quot;Circular Kernel Context Logger&quot; ... +0x114 InstanceGuid : _GUID {54dea73a-ed1f-42a4-af71-3e63d056f174} Upon configuring the logger and starting it, we’re ready to roll. Part 3: Hooking context switches We now have a function that gets called on each context switch - awesome! Finding the new thread is simple - we’re executing in its context, meaning KeGetCurrentThread will get us a pointer to it’s object. Looking at the functions called prior to our hook, we notice that the last function that has access to the OldThread and NewThread parameters is EtwpLogContextSwapEvent, where they are passed in rdx and r8. Breakpointing there shows that rbx and rdi contain copies of the two arguments. 1: kd&gt; r rbx, rdx, rdi, r8 rbx=ffffd8878177d080 rdx=ffffd8878177d080 rdi=ffffd8878627c080 r8=ffffd8878627c080 nt!EtwpLogContextSwapEvent: fffff8028bbd79d0 48895c2410 mov qword ptr [rsp+10h],rbx ss:0018:fffff500a54bbef8=fffff8028bbd7885 These registers are both pushed onto the stack in the function prologue, with the current thread (stored in rdi and r8) coming first: kd&gt; uu EtwpLogContextSwapEvent nt!EtwpLogContextSwapEvent: fffff805`81bd79d0 48895c2410 mov qword ptr [rsp+10h],rbx fffff805`81bd79d5 55 push rbp fffff805`81bd79d6 56 push rsi fffff805`81bd79d7 57 push rdi Looking at the code, we can figure out that rbx will be at a constant offset of 0x28 from rdi on the stack. Given we know the value of rdi (it’s a pointer to the current thread), we can scan the stack up from our hook, and look at each possible thread: // We loop until stack_limit - 0x28 to prevent OOB access when checking the previous thread. for (ULONG_PTR iterator = rsp; iterator &lt; (stack_limit - 0x28); iterator += sizeof(PKTHREAD)) { PKTHREAD thread_at_iterator = *reinterpret_cast&lt;PKTHREAD*&gt;(iterator); // If we found our own thread&#39;s pointer on the stack if (thread_at_iterator == current_thread) { // Look at the thread at the target offset PKTHREAD possible_prev_thread = *reinterpret_cast&lt;PKTHREAD*&gt;(iterator + 0x28); PDISPATCHER_HEADER possible_dispatcher_header = reinterpret_cast&lt;PDISPATCHER_HEADER&gt;(possible_prev_thread) - 1; const ULONG_PTR possible_prev_thread_raw = *reinterpret_cast&lt;ULONG_PTR*&gt;(iterator + 0x28); // Threads are not stack-allocated. if (possible_prev_thread_raw &gt;= stack_base &amp;&amp; possible_prev_thread_raw &lt;= stack_limit) continue; // Threads are not in userspace. if (possible_prev_thread &lt; MmSystemRangeStart) continue; // Threads have accessible memory. if (!MmIsAddressValid(possible_prev_thread) || !MmIsAddressValid(possible_dispatcher_header)) continue; // Reference the thread to check the object type. NTSTATUS status = ObReferenceObjectByPointer( possible_prev_thread, 0, *PsThreadType, KernelMode ); // If the function fails, we can be sure that the address is not one of a thread. if (!NT_SUCCESS(status)) continue; // Dereference the thread, and store it. ObfDereferenceObject(possible_prev_thread); previous_thread = possible_prev_thread; break; } } Part 4: Usage &amp; Detection Many anti-cheat solutions have started hooking context swaps in an effort to create hidden memory regions that are only visible to certain threads in the system. One notable example is Riot Vanguard which uses a different method that I’ll definitely write about in the near future. The hook can also be used to detect threads executing in unsigned memory, as there’s little preventing you from walking the stack of the old thread, and seeing whether code is running in any region it shouldn’t be. As for detection, there’s the obvious artifact of HalpPerformanceCounter + 0x70 pointing outside of ntoskrnl.exe, and GetCpuClock being set to 1 in the CKCL. Although the latter may happen under normal system operation (and could therefore trigger false positives), it’s never been set by default over the course of my testing. Part 5: Epilogue This is my very first written article, inspired by reading countless posts from people far smarter than I am. One person I should definitely mention is Denis Skvortcov who wrote about this method more than two years ago when reverse-engineering Avast Antivirus. I should also thank you, the reader, for sticking with me this far - I hope we meet again next time!" />
<link rel="canonical" href="http://localhost:4000/etw/hooking/2025/04/09/hooking-context-swaps-with-etw.html" />
<meta property="og:url" content="http://localhost:4000/etw/hooking/2025/04/09/hooking-context-swaps-with-etw.html" />
<meta property="og:site_name" content="Archie’s reversing diary" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2025-04-09T17:44:00+02:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Hooking Context Swaps with ETW" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Archie"},"dateModified":"2025-04-09T17:44:00+02:00","datePublished":"2025-04-09T17:44:00+02:00","description":"Event Tracing for Windows (ETW) is a kernel mechanism designed to log certain activity happening in the system. Despite its seemingly innocuous description, ETW can be a valuable source of information and a very interesting hook point for both anti-cheats and other drivers. Part 1: Finding the hook point All ETW logging functions eventually end up inside nt!EtwpLogKernelEvent which, in summary, reserves a buffer for the log using nt!EtwpReserveTraceBuffer and then writes the log to that buffer. Deep inside nt!EtwpReserveTraceBuffer is where the real fun begins. The function accesses a _WMI_LOGGER_CONTEXT structure - the kernel’s representation of a logger - and looks at the GetCpuClock member before deciding on how to get the current time. Anyone who’s ever looked at how InfinityHook works will immediately recognize this member variable, as it was the hook point used by its creators. In the past, the variable was a function pointer that could be directly swapped to easily gain execution at each captured event. In an effort to patch InfinityHook, Microsoft turned the variable into an index, with each index representing a different way of getting time. Looking at the relevant code inside EtwpReserveTraceBuffer, we can deduce what indices are valid, together with their meaning: const auto get_cpu_clock = LoggerContext-&gt;GetCpuClock; LARGE_INTEGER current_time = { .QuadPart = 0 }; // Crash the computer if the index is invalid. if (get_cpu_clock &gt; 3) KeBugCheck(KERNEL_SECURITY_CHECK_FAILURE); switch (get_cpu_clock) { case 3: current_time.QuadPart = __rdtsc(); break; case 2: HalPrivateDispatchTable.HalTimerQueryHostPerformanceCounter(&amp;current_time); break; case 1: current_time = KeQueryPerformanceCounter(nullptr); break; case 0: current_time = RtlGetSystemTimePrecise(); break; default: KeBugCheck(KERNEL_SECURITY_CHECK_FAILURE); } For the purposes of this article, we’ll focus on what happens when the value is set to 1. At the beginning of the nt!KeQueryPerformanceCounter function, we can see the following snippet: UINT32 value_1 = *reinterpret_cast&lt;UINT32*&gt;(HalpPerformanceCounter + 0xE4); UINT32 value_2 = *reinterpret_cast&lt;UINT32*&gt;(HalpPerformanceCounter + 0xDC); LARGE_INTEGER result = { .QuadPart = 0 }; // This seems to always be true if (value_1 == 5) { PVOID internal_data = HalpTimerGetInternalData(HalpPerformanceCounter); if (HalpTimerReferencePage) { result = HalpPerformanceCounter-&gt;HalpQueryCounter(internal_data); } else { // ... result = HalpPerformanceCounter-&gt;HalpQueryCounter(internal_data); // ... } } Simply swapping the pointer to HalpQueryCounter is enough to get us a hook. There is just one problem - nt!KeQueryPerformanceCounter is a function that is called very often. It’s also impossible to set a breakpoint inside, as any connected kernel debugger will hang upon the breakpoint being hit. To prevent false positives (and get our debugger to work again), we need to figure out if calls made to our hook come from ETW. In the tested version of Windows 11 24H2, there is a pointer to the logger context in the r15 register if the call comes from ETW. In other versions of Windows (mainly Windows 10), one may have to resort to scanning the stack for pointers to the logger context. Part 2: Configuring the logger Making ETW call our hook is not that simple - we will first need to access the GetCpuClock variable of the _WMI_LOGGER_CONTEXT structure to make the kernel call our hook. While it is possible to create a new logger and get a pointer to the structure that way, I chose to instead hijack the Circular Kernel Context Logger (CKCL), as it is usually not used for anything important. A pointer to its context can be retrieved quite easily, as there is a pointer chain that leads us right to it. This pointer chain is stable for all tested versions of Windows, and is unlikely to change in the future. It begins at the undocumented nt!EtwpDebuggerData global, whose RVA can be found via parsing the PDB of ntoskrnl.exe. PWMI_LOGGER_CONTEXT GetCKCLContext( IN UINT_PTR EtwpDebuggerData ) { PVOID* debugger_data_silo = *reinterpret_cast&lt;PVOID**&gt;(EtwpDebuggerData + 0x10); return static_cast&lt;PWMI_LOGGER_CONTEXT&gt;(debugger_data_silo[2]); } We will also need to configure the logger’s target events (internally called EnableFlags). This is done via the nt!ZwTraceControl function, which is thankfully exported for all drivers to use. The function takes a _WMI_LOGGER_INFORMATION structure as the input buffer. While undocumented by Microsoft, its definition can be found inside PHNT headers. Inside this structure, we will need to specify what logger to target. This is done by setting the GUID and LoggerName. Already having the _WMI_LOGGER_CONTEXT structure, extracting the information is simple: kd&gt; dt _WMI_LOGGER_CONTEXT poi(poi(EtwpDebuggerData+0x10)+0x10) nt!_WMI_LOGGER_CONTEXT ... +0x088 LoggerName : _UNICODE_STRING &quot;Circular Kernel Context Logger&quot; ... +0x114 InstanceGuid : _GUID {54dea73a-ed1f-42a4-af71-3e63d056f174} Upon configuring the logger and starting it, we’re ready to roll. Part 3: Hooking context switches We now have a function that gets called on each context switch - awesome! Finding the new thread is simple - we’re executing in its context, meaning KeGetCurrentThread will get us a pointer to it’s object. Looking at the functions called prior to our hook, we notice that the last function that has access to the OldThread and NewThread parameters is EtwpLogContextSwapEvent, where they are passed in rdx and r8. Breakpointing there shows that rbx and rdi contain copies of the two arguments. 1: kd&gt; r rbx, rdx, rdi, r8 rbx=ffffd8878177d080 rdx=ffffd8878177d080 rdi=ffffd8878627c080 r8=ffffd8878627c080 nt!EtwpLogContextSwapEvent: fffff8028bbd79d0 48895c2410 mov qword ptr [rsp+10h],rbx ss:0018:fffff500a54bbef8=fffff8028bbd7885 These registers are both pushed onto the stack in the function prologue, with the current thread (stored in rdi and r8) coming first: kd&gt; uu EtwpLogContextSwapEvent nt!EtwpLogContextSwapEvent: fffff805`81bd79d0 48895c2410 mov qword ptr [rsp+10h],rbx fffff805`81bd79d5 55 push rbp fffff805`81bd79d6 56 push rsi fffff805`81bd79d7 57 push rdi Looking at the code, we can figure out that rbx will be at a constant offset of 0x28 from rdi on the stack. Given we know the value of rdi (it’s a pointer to the current thread), we can scan the stack up from our hook, and look at each possible thread: // We loop until stack_limit - 0x28 to prevent OOB access when checking the previous thread. for (ULONG_PTR iterator = rsp; iterator &lt; (stack_limit - 0x28); iterator += sizeof(PKTHREAD)) { PKTHREAD thread_at_iterator = *reinterpret_cast&lt;PKTHREAD*&gt;(iterator); // If we found our own thread&#39;s pointer on the stack if (thread_at_iterator == current_thread) { // Look at the thread at the target offset PKTHREAD possible_prev_thread = *reinterpret_cast&lt;PKTHREAD*&gt;(iterator + 0x28); PDISPATCHER_HEADER possible_dispatcher_header = reinterpret_cast&lt;PDISPATCHER_HEADER&gt;(possible_prev_thread) - 1; const ULONG_PTR possible_prev_thread_raw = *reinterpret_cast&lt;ULONG_PTR*&gt;(iterator + 0x28); // Threads are not stack-allocated. if (possible_prev_thread_raw &gt;= stack_base &amp;&amp; possible_prev_thread_raw &lt;= stack_limit) continue; // Threads are not in userspace. if (possible_prev_thread &lt; MmSystemRangeStart) continue; // Threads have accessible memory. if (!MmIsAddressValid(possible_prev_thread) || !MmIsAddressValid(possible_dispatcher_header)) continue; // Reference the thread to check the object type. NTSTATUS status = ObReferenceObjectByPointer( possible_prev_thread, 0, *PsThreadType, KernelMode ); // If the function fails, we can be sure that the address is not one of a thread. if (!NT_SUCCESS(status)) continue; // Dereference the thread, and store it. ObfDereferenceObject(possible_prev_thread); previous_thread = possible_prev_thread; break; } } Part 4: Usage &amp; Detection Many anti-cheat solutions have started hooking context swaps in an effort to create hidden memory regions that are only visible to certain threads in the system. One notable example is Riot Vanguard which uses a different method that I’ll definitely write about in the near future. The hook can also be used to detect threads executing in unsigned memory, as there’s little preventing you from walking the stack of the old thread, and seeing whether code is running in any region it shouldn’t be. As for detection, there’s the obvious artifact of HalpPerformanceCounter + 0x70 pointing outside of ntoskrnl.exe, and GetCpuClock being set to 1 in the CKCL. Although the latter may happen under normal system operation (and could therefore trigger false positives), it’s never been set by default over the course of my testing. Part 5: Epilogue This is my very first written article, inspired by reading countless posts from people far smarter than I am. One person I should definitely mention is Denis Skvortcov who wrote about this method more than two years ago when reverse-engineering Avast Antivirus. I should also thank you, the reader, for sticking with me this far - I hope we meet again next time!","headline":"Hooking Context Swaps with ETW","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/etw/hooking/2025/04/09/hooking-context-swaps-with-etw.html"},"url":"http://localhost:4000/etw/hooking/2025/04/09/hooking-context-swaps-with-etw.html"}</script>
<!-- End Jekyll SEO tag -->
<link id="main-stylesheet" rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Archie&apos;s reversing diary" />
</head>
<body><header class="site-header">

  <div class="wrapper">
    <a class="site-title" rel="author" href="/">Archie&#39;s reversing diary</a>
      <nav class="site-nav">
        <input type="checkbox" id="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon"></span>
        </label>

        <div class="nav-items">
  <a class="nav-item" href="/about/">About</a>
</div>

      </nav>
  </div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Hooking Context Swaps with ETW</h1>
    <div class="post-meta">
      <time class="dt-published" datetime="2025-04-09T17:44:00+02:00" itemprop="datePublished">
        Apr 9, 2025
      </time>
    </div>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>Event Tracing for Windows (ETW) is a kernel mechanism designed to log certain activity happening in the system. Despite its seemingly innocuous description, ETW can be a valuable source of information and a very interesting hook point for both anti-cheats and other drivers.</p>

<h2 id="part-1-finding-the-hook-point">Part 1: Finding the hook point</h2>
<p>All ETW logging functions eventually end up inside <code class="language-plaintext highlighter-rouge">nt!EtwpLogKernelEvent</code> which, in summary, reserves a buffer for the log using <code class="language-plaintext highlighter-rouge">nt!EtwpReserveTraceBuffer</code> and then writes the log to that buffer.</p>

<p>Deep inside <code class="language-plaintext highlighter-rouge">nt!EtwpReserveTraceBuffer</code> is where the real fun begins. The function accesses a <code class="language-plaintext highlighter-rouge">_WMI_LOGGER_CONTEXT</code> structure - the kernel’s representation of a logger - and looks at the <code class="language-plaintext highlighter-rouge">GetCpuClock</code> member before deciding on how to get the current time.</p>

<p>Anyone who’s ever looked at how <em><a href="https://github.com/everdox/InfinityHook">InfinityHook</a></em> works will immediately recognize this member variable, as it was the hook point used by its creators. In the past, the variable was a function pointer that could be directly swapped to easily gain execution at each captured event. In an effort to patch <em>InfinityHook</em>, Microsoft turned the variable into an index, with each index representing a different way of getting time.</p>

<p>Looking at the relevant code inside <code class="language-plaintext highlighter-rouge">EtwpReserveTraceBuffer</code>, we can deduce what indices are valid, together with their meaning:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="k">auto</span> <span class="n">get_cpu_clock</span> <span class="o">=</span> <span class="n">LoggerContext</span><span class="o">-&gt;</span><span class="n">GetCpuClock</span><span class="p">;</span>
<span class="n">LARGE_INTEGER</span> <span class="n">current_time</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">QuadPart</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">};</span>

<span class="c1">// Crash the computer if the index is invalid.</span>
<span class="k">if</span> <span class="p">(</span><span class="n">get_cpu_clock</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">KeBugCheck</span><span class="p">(</span><span class="n">KERNEL_SECURITY_CHECK_FAILURE</span><span class="p">);</span>

<span class="k">switch</span> <span class="p">(</span><span class="n">get_cpu_clock</span><span class="p">)</span>
<span class="p">{</span>
<span class="k">case</span> <span class="mi">3</span><span class="p">:</span>
    <span class="n">current_time</span><span class="p">.</span><span class="n">QuadPart</span> <span class="o">=</span> <span class="n">__rdtsc</span><span class="p">();</span>
    <span class="k">break</span><span class="p">;</span>
<span class="k">case</span> <span class="mi">2</span><span class="p">:</span>
    <span class="n">HalPrivateDispatchTable</span><span class="p">.</span><span class="n">HalTimerQueryHostPerformanceCounter</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current_time</span><span class="p">);</span>
    <span class="k">break</span><span class="p">;</span>
<span class="k">case</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">current_time</span> <span class="o">=</span> <span class="n">KeQueryPerformanceCounter</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">);</span>
    <span class="k">break</span><span class="p">;</span>
<span class="k">case</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">current_time</span> <span class="o">=</span> <span class="n">RtlGetSystemTimePrecise</span><span class="p">();</span>
    <span class="k">break</span><span class="p">;</span>
<span class="nl">default:</span>
    <span class="n">KeBugCheck</span><span class="p">(</span><span class="n">KERNEL_SECURITY_CHECK_FAILURE</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>For the purposes of this article, we’ll focus on what happens when the value is set to <code class="language-plaintext highlighter-rouge">1</code>. At the beginning of the <code class="language-plaintext highlighter-rouge">nt!KeQueryPerformanceCounter</code> function, we can see the following snippet:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">UINT32</span> <span class="n">value_1</span> <span class="o">=</span> <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">UINT32</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">HalpPerformanceCounter</span> <span class="o">+</span> <span class="mh">0xE4</span><span class="p">);</span>
<span class="n">UINT32</span> <span class="n">value_2</span> <span class="o">=</span> <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">UINT32</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">HalpPerformanceCounter</span> <span class="o">+</span> <span class="mh">0xDC</span><span class="p">);</span>
<span class="n">LARGE_INTEGER</span> <span class="n">result</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">QuadPart</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">};</span>

<span class="c1">// This seems to always be true</span>
<span class="k">if</span> <span class="p">(</span><span class="n">value_1</span> <span class="o">==</span> <span class="mi">5</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PVOID</span> <span class="n">internal_data</span> <span class="o">=</span> <span class="n">HalpTimerGetInternalData</span><span class="p">(</span><span class="n">HalpPerformanceCounter</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">HalpTimerReferencePage</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">HalpPerformanceCounter</span><span class="o">-&gt;</span><span class="n">HalpQueryCounter</span><span class="p">(</span><span class="n">internal_data</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="c1">// ...</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">HalpPerformanceCounter</span><span class="o">-&gt;</span><span class="n">HalpQueryCounter</span><span class="p">(</span><span class="n">internal_data</span><span class="p">);</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>Simply swapping the pointer to <code class="language-plaintext highlighter-rouge">HalpQueryCounter</code> is enough to get us a hook. There is just one problem - <code class="language-plaintext highlighter-rouge">nt!KeQueryPerformanceCounter</code> is a function that is called <strong>very</strong> often. It’s also impossible to set a breakpoint inside, as any connected kernel debugger will hang upon the breakpoint being hit.</p>

<p>To prevent false positives (and get our debugger to work again), we need to figure out if calls made to our hook come from ETW. In the tested version of Windows 11 24H2, there is a pointer to the logger context in the <code class="language-plaintext highlighter-rouge">r15</code> register if the call comes from ETW. In other versions of Windows (mainly Windows 10), one may have to resort to scanning the stack for pointers to the logger context.</p>

<h2 id="part-2-configuring-the-logger">Part 2: Configuring the logger</h2>
<p>Making ETW call our hook is not that simple - we will first need to access the <code class="language-plaintext highlighter-rouge">GetCpuClock</code> variable of the <code class="language-plaintext highlighter-rouge">_WMI_LOGGER_CONTEXT</code> structure to make the kernel call our hook. While it is possible to create a new logger and get a pointer to the structure that way, I chose to instead hijack the <strong>Circular Kernel Context Logger</strong> (CKCL), as it is usually not used for anything important. A pointer to its context can be retrieved quite easily, as there is a pointer chain that leads us right to it.</p>

<p>This pointer chain is stable for all tested versions of Windows, and is unlikely to change in the future. It begins at the undocumented <code class="language-plaintext highlighter-rouge">nt!EtwpDebuggerData</code> global, whose RVA can be found via parsing the PDB of <code class="language-plaintext highlighter-rouge">ntoskrnl.exe</code>.</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">PWMI_LOGGER_CONTEXT</span> <span class="nf">GetCKCLContext</span><span class="p">(</span>
    <span class="n">IN</span> <span class="n">UINT_PTR</span> <span class="n">EtwpDebuggerData</span>
<span class="p">)</span>
<span class="p">{</span>
    <span class="n">PVOID</span><span class="o">*</span> <span class="n">debugger_data_silo</span> <span class="o">=</span> <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">PVOID</span><span class="o">**&gt;</span><span class="p">(</span><span class="n">EtwpDebuggerData</span> <span class="o">+</span> <span class="mh">0x10</span><span class="p">);</span>
    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">PWMI_LOGGER_CONTEXT</span><span class="o">&gt;</span><span class="p">(</span><span class="n">debugger_data_silo</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>We will also need to configure the logger’s target events (internally called <code class="language-plaintext highlighter-rouge">EnableFlags</code>). This is done via the <code class="language-plaintext highlighter-rouge">nt!ZwTraceControl</code> function, which is thankfully exported for all drivers to use.</p>

<p>The function takes a <code class="language-plaintext highlighter-rouge">_WMI_LOGGER_INFORMATION</code> structure as the input buffer. While undocumented by Microsoft, its definition can be found inside <a href="https://ntdoc.m417z.com/wmi_logger_information">PHNT headers</a>. Inside this structure, we will need to specify what logger to target. This is done by setting the <code class="language-plaintext highlighter-rouge">GUID</code> and <code class="language-plaintext highlighter-rouge">LoggerName</code>.</p>

<p>Already having the <code class="language-plaintext highlighter-rouge">_WMI_LOGGER_CONTEXT</code> structure, extracting the information is simple:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kd&gt; dt _WMI_LOGGER_CONTEXT poi(poi(EtwpDebuggerData+0x10)+0x10)
nt!_WMI_LOGGER_CONTEXT
    ...
    +0x088 LoggerName       : _UNICODE_STRING "Circular Kernel Context Logger"
    ...
    +0x114 InstanceGuid     : _GUID {54dea73a-ed1f-42a4-af71-3e63d056f174}
</code></pre></div></div>
<p>Upon configuring the logger and starting it, we’re ready to roll.</p>
<h2 id="part-3-hooking-context-switches">Part 3: Hooking context switches</h2>
<p>We now have a function that gets called on each context switch - awesome! Finding the new thread is simple - we’re executing in its context, meaning <code class="language-plaintext highlighter-rouge">KeGetCurrentThread</code> will get us a pointer to it’s object.</p>

<p>Looking at the functions called prior to our hook, we notice that the last function that has access to the <code class="language-plaintext highlighter-rouge">OldThread</code> and <code class="language-plaintext highlighter-rouge">NewThread</code> parameters is <code class="language-plaintext highlighter-rouge">EtwpLogContextSwapEvent</code>, where they are passed in <code class="language-plaintext highlighter-rouge">rdx</code> and <code class="language-plaintext highlighter-rouge">r8</code>. Breakpointing there shows that <code class="language-plaintext highlighter-rouge">rbx</code> and <code class="language-plaintext highlighter-rouge">rdi</code> contain copies of the two arguments.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1: kd&gt; r rbx, rdx, rdi, r8
rbx=ffffd8878177d080 rdx=ffffd8878177d080 
rdi=ffffd8878627c080 r8=ffffd8878627c080
nt!EtwpLogContextSwapEvent:
fffff8028bbd79d0 48895c2410      mov     qword ptr [rsp+10h],rbx ss:0018:fffff500a54bbef8=fffff8028bbd7885
</code></pre></div></div>
<p>These registers are both pushed onto the stack in the function prologue, with the current thread (stored in <code class="language-plaintext highlighter-rouge">rdi</code> and <code class="language-plaintext highlighter-rouge">r8</code>) coming first:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>kd&gt; uu EtwpLogContextSwapEvent
nt!EtwpLogContextSwapEvent:
fffff805`81bd79d0 48895c2410      mov     qword ptr [rsp+10h],rbx
fffff805`81bd79d5 55              push    rbp
fffff805`81bd79d6 56              push    rsi
fffff805`81bd79d7 57              push    rdi
</code></pre></div></div>
<p>Looking at the code, we can figure out that <code class="language-plaintext highlighter-rouge">rbx</code> will be at a constant offset of <code class="language-plaintext highlighter-rouge">0x28</code> from <code class="language-plaintext highlighter-rouge">rdi</code> on the stack. Given we know the value of <code class="language-plaintext highlighter-rouge">rdi</code> (it’s a pointer to the current thread), we can scan the stack up from our hook, and look at each possible thread:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// We loop until stack_limit - 0x28 to prevent OOB access when checking the previous thread.</span>
<span class="k">for</span> <span class="p">(</span><span class="n">ULONG_PTR</span> <span class="n">iterator</span> <span class="o">=</span> <span class="n">rsp</span><span class="p">;</span> <span class="n">iterator</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">stack_limit</span> <span class="o">-</span> <span class="mh">0x28</span><span class="p">);</span> <span class="n">iterator</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">PKTHREAD</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">PKTHREAD</span> <span class="n">thread_at_iterator</span> <span class="o">=</span> <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">PKTHREAD</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">iterator</span><span class="p">);</span>

    <span class="c1">// If we found our own thread's pointer on the stack</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">thread_at_iterator</span> <span class="o">==</span> <span class="n">current_thread</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// Look at the thread at the target offset</span>
        <span class="n">PKTHREAD</span> <span class="n">possible_prev_thread</span> <span class="o">=</span> <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">PKTHREAD</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">iterator</span> <span class="o">+</span> <span class="mh">0x28</span><span class="p">);</span>
        <span class="n">PDISPATCHER_HEADER</span> <span class="n">possible_dispatcher_header</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">PDISPATCHER_HEADER</span><span class="o">&gt;</span><span class="p">(</span><span class="n">possible_prev_thread</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">const</span> <span class="n">ULONG_PTR</span> <span class="n">possible_prev_thread_raw</span> <span class="o">=</span> <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">ULONG_PTR</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">iterator</span> <span class="o">+</span> <span class="mh">0x28</span><span class="p">);</span>
        <span class="c1">// Threads are not stack-allocated.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">possible_prev_thread_raw</span> <span class="o">&gt;=</span> <span class="n">stack_base</span> <span class="o">&amp;&amp;</span> <span class="n">possible_prev_thread_raw</span> <span class="o">&lt;=</span> <span class="n">stack_limit</span><span class="p">)</span>
            <span class="k">continue</span><span class="p">;</span>

        <span class="c1">// Threads are not in userspace.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">possible_prev_thread</span> <span class="o">&lt;</span> <span class="n">MmSystemRangeStart</span><span class="p">)</span>
            <span class="k">continue</span><span class="p">;</span>

        <span class="c1">// Threads have accessible memory.</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">MmIsAddressValid</span><span class="p">(</span><span class="n">possible_prev_thread</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">MmIsAddressValid</span><span class="p">(</span><span class="n">possible_dispatcher_header</span><span class="p">))</span>
            <span class="k">continue</span><span class="p">;</span>

        <span class="c1">// Reference the thread to check the object type.</span>
        <span class="n">NTSTATUS</span> <span class="n">status</span> <span class="o">=</span> <span class="n">ObReferenceObjectByPointer</span><span class="p">(</span>
            <span class="n">possible_prev_thread</span><span class="p">,</span>
            <span class="mi">0</span><span class="p">,</span>
            <span class="o">*</span><span class="n">PsThreadType</span><span class="p">,</span>
            <span class="n">KernelMode</span>
        <span class="p">);</span>

        <span class="c1">// If the function fails, we can be sure that the address is not one of a thread.</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">NT_SUCCESS</span><span class="p">(</span><span class="n">status</span><span class="p">))</span>
            <span class="k">continue</span><span class="p">;</span>

        <span class="c1">// Dereference the thread, and store it.</span>
        <span class="n">ObfDereferenceObject</span><span class="p">(</span><span class="n">possible_prev_thread</span><span class="p">);</span>
        <span class="n">previous_thread</span> <span class="o">=</span> <span class="n">possible_prev_thread</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<h2 id="part-4-usage--detection">Part 4: Usage &amp; Detection</h2>
<p>Many anti-cheat solutions have started hooking context swaps in an effort to create hidden memory regions that are only visible to certain threads in the system. One notable example is <a href="https://support-valorant.riotgames.com/hc/en-us/articles/360046160933-What-is-Vanguard">Riot Vanguard</a> which uses a different method that I’ll definitely write about in the near future.</p>

<p>The hook can also be used to detect threads executing in unsigned memory, as there’s little preventing you from walking the stack of the old thread, and seeing whether code is running in any region it shouldn’t be.</p>

<p>As for detection, there’s the obvious artifact of <code class="language-plaintext highlighter-rouge">HalpPerformanceCounter + 0x70</code> pointing outside of <code class="language-plaintext highlighter-rouge">ntoskrnl.exe</code>, and <code class="language-plaintext highlighter-rouge">GetCpuClock</code> being set to 1 in the CKCL. Although the latter may happen under normal system operation (and could therefore trigger false positives), it’s never been set by default over the course of my testing.</p>

<h2 id="part-5-epilogue">Part 5: Epilogue</h2>
<p>This is my very first written article, inspired by reading countless posts from people far smarter than I am. One person I should definitely mention is <a href="https://the-deniss.github.io/">Denis Skvortcov</a> who wrote about this method <a href="https://the-deniss.github.io/posts/2022/12/08/hooking-system-calls-in-windows-11-22h2-like-avast-antivirus.html">more than two years ago</a> when reverse-engineering Avast Antivirus.</p>

<p>I should also thank you, the reader, for sticking with me this far - I hope we meet again next time!</p>

  </div>

  <a class="u-url" href="/etw/hooking/2025/04/09/hooking-context-swaps-with-etw.html" hidden></a>
</article>

      </div>
    </main><link id="fa-stylesheet" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css">

<footer class="site-footer h-card">
  <data class="u-url" value="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="http://localhost:4000/feed.xml">
            <svg class="svg-icon orange">
              <path d="M12.8 16C12.8 8.978 7.022 3.2 0 3.2V0c8.777 0 16 7.223 16 16h-3.2zM2.194
                11.61c1.21 0 2.195.985 2.195 2.196 0 1.21-.99 2.194-2.2 2.194C.98 16 0 15.017 0
                13.806c0-1.21.983-2.195 2.194-2.195zM10.606
                16h-3.11c0-4.113-3.383-7.497-7.496-7.497v-3.11c5.818 0 10.606 4.79 10.606 10.607z"
              />
            </svg><span>Subscribe</span>
          </a>
        </p>
        <ul class="contact-list">
          
        </ul>
      </div>
      <div class="footer-col">
        <p>I just do random reverse engineering.</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"></ul>
</div>

  </div>

</footer>

</body>

</html>
